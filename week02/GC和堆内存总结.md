# GC 算法
标记-复制。优点：存活的对象越少，复制需要的空间就越小；而且复制后的对象们内存空间排布紧凑，避免空间碎片的问题。缺点：有一部分空间被浪费。如果存活对象大且多的话复制成本比较高。适用每次 GC 存活对象小而美的情况。年轻代
标记-清除。直接清除可回收对象，不进行内存整理。，优点：单次 STW 的时间可能要短一些。缺点：但是产生的内存碎片，可能导致内存总空间足够，但是没一块连续的空间存放对象的问题，内存利用率降低；对象放不下，可能触发额外的 GC。适用对象存活率高的情况。老年代
标记-清除-整理。STW 时间可能会稍长一些，内存碎片问题得到解决。适用对象存活率高的情况。

# Serial GC
-XX:+UseSerialGC
串行 GC 单线程执行，在 GC 期间其他业务线程均暂停，暂停的时间长。
串行 GC 对年轻代采用标记复制算法。对老年代使用标记-清除-整理算法。
串行 GC 简单直接，在单核 CPU 环境下比较适用。

# -XX:+UseParNewGC
ParNew 收集器，多线程版本的 Serial。配合 CMS 使用。

# Parallel GC
-XX:UseParallelGC -XX:UseParallelOldGC
使用的 GC 算法和串行的一样。
默认的 GC 线程数是 CPU core 数，该收集器的目标更倾向于提高系统吞吐量，有时候单次的 GC 暂停时间较长。

# CMS GC
-XX:UseConcMarkSweepGC
对老年代没有整理操作，使用 free-list 进行内存空间的管理。默认的核心线程数 CPU 核数 / 4。
可以和业务线程并发执行，GC 暂停时间少。

# G1 GC
打破整个分区的理论，把内存划分成多个小块进行管理。对每个小块的垃圾数量进行预估，优先回收垃圾多的 Region。可预期的垃圾停顿时间。
